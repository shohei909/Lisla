// Generated by Haxe 3.4.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldHashConflict {
		
		public FieldHashConflict(int hash, string name, object @value, global::haxe.lang.FieldHashConflict next) {
			this.hash = hash;
			this.name = name;
			this.@value = @value;
			this.next = next;
		}
		
		
		public readonly int hash;
		
		public readonly string name;
		
		public object @value;
		
		public global::haxe.lang.FieldHashConflict next;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{98, 105, 109, 22191, 1821933, 2503796, 4518093, 4745537, 4846113, 4849249, 4949376, 5047259, 5393365, 5395604, 5442204, 5442212, 5443986, 5594513, 5594516, 5693978, 5695307, 5744817, 5790298, 5793429, 23311511, 24046298, 46374763, 52644165, 57476627, 57607912, 63190583, 66083509, 67859985, 68555745, 76061764, 87367608, 93036843, 97637140, 100394802, 100628555, 116192081, 142895325, 156956385, 164354652, 169944894, 208459108, 228259843, 235988664, 243225909, 261031087, 279665676, 288167040, 288368849, 302979532, 328878574, 334695532, 350619104, 352946627, 359333139, 407283053, 427265337, 437335495, 450530839, 452737314, 454225691, 457663475, 457934357, 480576300, 493819893, 501039929, 520590566, 537630174, 569771653, 596443070, 608461286, 630156697, 634405118, 641597244, 652994848, 653524162, 675149733, 701410669, 716854799, 746281503, 752681381, 767706546, 777407032, 782497038, 803626893, 834174833, 842117339, 894737789, 902460965, 913309472, 924641663, 943677095, 944645571, 946786476, 982781041, 1007824183, 1041537810, 1058556349, 1067353468, 1083595454, 1087583404, 1092664259, 1101415895, 1103409453, 1103412149, 1111044774, 1112160627, 1113806378, 1114501250, 1126573719, 1135983070, 1136381564, 1140241735, 1156359202, 1158519427, 1158559586, 1181037546, 1184833344, 1191829844, 1202919412, 1204816148, 1204967106, 1214453688, 1217091629, 1224700491, 1224901875, 1228056441, 1234340137, 1246881189, 1247875546, 1257939113, 1269254998, 1270620251, 1273207865, 1276592493, 1280845662, 1282943179, 1292432058, 1330771252, 1337328427, 1347548074, 1350392273, 1352786672, 1365803947, 1367260842, 1382942234, 1393790903, 1398464674, 1405312536, 1415380210, 1417420914, 1431819701, 1436822557, 1450762973, 1456324261, 1459008674, 1483379067, 1493851956, 1503919382, 1507500847, 1512997393, 1532710347, 1547539107, 1571990705, 1588891418, 1590554466, 1607340315, 1620824029, 1621420777, 1623148745, 1636892380, 1638129397, 1648581351, 1675385244, 1679795645, 1695518283, 1705629508, 1715662431, 1718995411, 1723805383, 1729346288, 1744750013, 1761135745, 1762763342, 1763375486, 1768617329, 1772803423, 1784361120, 1805631789, 1809902070, 1813514790, 1818678820, 1823856450, 1836975402, 1856361165, 1871198603, 1873743348, 1900716655, 1906201721, 1913895454, 1915412854, 1916009602, 1932118984, 1939813770, 1955375594, 1963056639, 1963356567, 1964446609, 1981972957, 1993182295, 1998201424, 2000440561, 2004862068, 2025055113, 2030465733, 2036280656, 2049945213, 2054707467, 2054731130, 2070512903, 2074818547, 2075837769, 2082663554, 2105872637, 2106494775, 2127021138, 2129499878};
		
		protected static string[] fields = new string[]{"b", "i", "m", "cr", "isGlobal", "startUnquotedString", "currentLine", "__a", "add", "arr", "cur", "end", "len", "low", "map", "max", "min", "pop", "pos", "row", "run", "str", "tag", "top", "outerIndex", "split", "readAll", "match", "getEnumConstructs", "assertLitllArray", "elements", "addLine", "state", "store", "remove", "filter", "currentTest", "packageDeclaration", "status", "packagePath", "target", "result", "method", "warning", "importDeclarations", "parseString", "processedValue", "addQuotes", "readBytes", "get_length", "assertNotEquals", "stream", "string", "methodName", "iterator", "indent", "getData", "isCoreType", "lastIndexOf", "hasNext", "content", "message", "toPascalCase", "reverse", "document", "isSlash", "endOpennigQuote", "createError", "getBytes", "insert", "length", "get_message", "getOuterPositionOf", "endArray", "makeErrorMessages", "array", "elementTag", "async", "invalidNumber", "toVariableName", "readWithDefault", "invalidChar", "outerLine", "contains", "assertEquals", "maybeCauses", "popStringTag", "toStringTag", "outputsDocument", "value", "source", "keeping", "typeName", "endClosedQuotedString", "typePath", "globalTearDown", "success", "toString", "modulePath", "endIndex", "index", "_eof", "splice", "readLabel", "module", "cases", "startArray", "code", "copy", "innerMap", "maybeErrors", "data", "done", "testDelitllfy", "fail", "file", "getRange", "testCase", "endInterporation", "high", "join", "writeComment", "kind", "line", "concat", "config", "close", "print", "name", "next", "enumConstructor", "createErrorResult", "path", "push", "position", "read", "printError", "current", "addIndent", "sort", "quicksort", "type", "assertTrue", "startPosition", "positions", "padding", "spliceVoid", "errors", "parameters", "globalSetup", "matchQuote", "getEnumName", "testFailure", "popArrayTag", "_openPreprocessResult", "createEnumIndex", "createEnum", "parseRec", "addFatalError", "assertLitllString", "getKindString", "leadingTag", "readOptional", "isInHead", "posInfos", "concatNative", "className", "processBody", "writeDocument", "lastIndent", "outputsPosition", "__unsafe_get", "__unsafe_set", "indexOf", "toArrayTag", "startQuoteCount", "fileName", "innerIndex", "range", "pushString", "toDynamic", "isWhite", "processOpeningQuote", "regex", "defaultValue", "failed", "sourceMap", "persevering", "readByte", "allEnums", "pushArray", "readData", "storedData", "currentResult", "get_lineNumber", "tearDown", "followings", "parent", "closeOrError", "settle", "label", "process", "endUnclosedQuotedString", "toArray", "__get", "__set", "error", "readRest", "currentString", "lines", "litll", "testSuccess", "lineNumber", "getModuleArray", "singleQuoted", "assertLitll", "newLine", "unshift", "stringKind", "entries", "setup", "enumParameters", "endTop", "_package", "assertThrows", "popTag", "shift", "assertFalse", "format", "slice", "typeDefinitions"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					uint _g_idx = default(uint);
					int[] _g_arr = nids;
					_g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						if (( global::haxe.lang.FieldLookup.findHash(((int) (_g_arr[((int) (_g_idx++) )]) ), cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( (( ci < clen )) ? (( ni < nlen )) : (false) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = cfields[ci];
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = nfields[ni];
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ( (( max - min )) / 2 ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return global::haxe.lang.FieldLookup.fields[mid];
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (string.Equals(s, null)) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						if ( ! (string.Equals(fld[mid], s)) ) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.insert<int>(ref global::haxe.lang.FieldLookup.fieldIds, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((int) (key) ));
					global::haxe.lang.FieldLookup.insert<string>(ref global::haxe.lang.FieldLookup.fields, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((string) (s) ));
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ( (( max + min )) / 2 );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void @remove<T>(T[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = default(T);
			}
		}
		
		
		public static void insert<T>(ref T[] a, int length, int pos, T x) {
			unchecked {
				int capacity = ( a as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						T[] newarr = new T[( (( length << 1 )) + 1 )];
						( a as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a = ((T[]) (newarr) );
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						T[] newarr1 = new T[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a = ((T[]) (newarr1) );
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					T[] newarr2 = new T[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a = ((T[]) (newarr2) );
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a[pos] = x;
			}
		}
		
		
		public static global::haxe.lang.FieldHashConflict getHashConflict(global::haxe.lang.FieldHashConflict head, int hash, string name) {
			while (( head != null )) {
				if (( ( head.hash == hash ) && string.Equals(head.name, name) )) {
					return head;
				}
				
				head = head.next;
			}
			
			return null;
		}
		
		
		public static void setHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name, object @value) {
			global::haxe.lang.FieldHashConflict node = head;
			while (( node != null )) {
				if (( ( node.hash == hash ) && string.Equals(node.name, name) )) {
					node.@value = @value;
					return;
				}
				
				node = ((global::haxe.lang.FieldHashConflict) (node.next) );
			}
			
			head = ((global::haxe.lang.FieldHashConflict) (new global::haxe.lang.FieldHashConflict(hash, name, @value, ((global::haxe.lang.FieldHashConflict) (head) ))) );
		}
		
		
		public static bool deleteHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name) {
			if (( head == null )) {
				return false;
			}
			
			if (( ( head.hash == hash ) && string.Equals(head.name, name) )) {
				head = ((global::haxe.lang.FieldHashConflict) (head.next) );
				return true;
			}
			
			global::haxe.lang.FieldHashConflict prev = head;
			global::haxe.lang.FieldHashConflict node = head.next;
			while (( node != null )) {
				if (( ( node.hash == hash ) && string.Equals(node.name, name) )) {
					prev.next = node.next;
					return true;
				}
				
				node = node.next;
			}
			
			return false;
		}
		
		
		public static void addHashConflictNames(global::haxe.lang.FieldHashConflict head, global::Array<object> arr) {
			while (( head != null )) {
				arr.push(head.name);
				head = head.next;
			}
			
		}
		
		
	}
}


