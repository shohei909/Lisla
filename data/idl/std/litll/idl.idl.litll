/// 'IDL for Litll Interface Description Language (Litll IDL)'
/// [license "Public Domain"]

[package litll]

[import litll.core]

/// [document_tag litll.idl.document.IdlDocumentTag]
[tuple Idl
    [package_declaration PackageDeclaration]
    [import_declarations.. ImportDeclaration]
    [type_definitions.. TypeDefinition]
]

[tuple PackageDeclaration
    package [package PackagePath]
]

[tuple ImportDeclaration
    import [module ModulePath]
]

/// [document_tag litll.idl.document.TypeDefinitionDocumentTag]
[enum TypeDefinition
    [newtype [name TypeNameDeclaration] [type TypeReference]]
    [tuple [name TypeNameDeclaration] [arguments.. TupleElement]]
    [enum [name TypeNameDeclaration] [constructors.. EnumConstructor]]
    [struct [name TypeNameDeclaration] [fields.. StructElement]]
]

[enum TypeNameDeclaration
    [primitive< [name TypeName]]
    [generic: [name TypeName] [parameters.. TypeParameterDeclaration]]
]
[enum TypeParameterDeclaration
    [type_name< [type_name TypeName]]
    [dependence< [declaration TypeDependenceDeclaration]]
]
/// '''
/// Uppercase and lowercase ASCII Latin letters A-Z (\u0041-\u005a), and a-z (\u0061-\u007a), and the ASCII underscore(_) are allowed. 
/// '''
[newtype TypeName String]
[tuple TypeDependenceDeclaration
    [name TypeDependenceName] [type TypeReference]
]
[newtype TypeDependenceName String]

[enum TupleElement
    [label< [constant String]]
    [argument< [argument Argument]]
]
[tuple Argument
    [name ArgumentName]
    [type TypeReference]
    [default_value? Any]
]

/// '''
/// Uppercase and lowercase ASCII Latin letters A-Z (\u0041-\u005a), and a-z (\u0061-\u007a), and the ASCII underscore(_) are allowed. 
/// Additionally, the following suffixes are supported.
/// "?"   : Optional argument. (default value is disabled)
/// ".."  : Rest arguments. (default value is disabled)
/// "<"   : Unfolded argument. (default value is disabled)
/// 
/// ## Restriction
/// ### Unfoldable type
///     String
///     Array
///     Tuple
///     Enum
///     Struct
/// 
/// In other words, all type can be unfolded. Newtype resolves to one of the above types.
/// '''
[newtype ArgumentName String]

[enum EnumConstructor
    [primitive< [name EnumConstructorName]]
    [parameterized< [parameterized ParameterizedEnumConstructor]]
]
[tuple ParameterizedEnumConstructor
    [name EnumConstructorName] [elements.. TupleElement]
]

/// '''
/// Additionally, the following suffixes are supported.
/// ":"  : Tuple style. Its first element have not to be label.
/// "<"   : Unfolding argument. Its argument must be one and the argument is unfolded
/// "_"   : Explicit normal field.
/// 
/// ## Restriction
/// ### Unfoldable type
///     Array
///     Tuple
///     Enum
///     Struct
/// 
/// #### Not unfoldable type
///     String
/// '''
[newtype EnumConstructorName String]

[enum StructElement
    [label<
        /// 'and unfolding suffix are disabled'
        [name StructFieldName]
    ]
    [nested_label: 
        /// 'and unfolding suffix are disabled'
        [name StructFieldName]
    ]
    [field< [field StructField]]
]
[tuple StructField
    [name StructFieldName]
    [type TypeReference]
    [default_value? Any]
]

/// ''' 
/// The following suffixes are supported
/// "?"   : Optional field. (default value is disabled)
/// ".."  : Multiple field. (default value is disabled)
/// "<"   : Unfolding field. 
/// "?<"  : Optional unfolding field. (default value is disabled)
/// "..<" : Multiple unfolding field. (default value is disabled)
/// "<<"  : Merge struct fields. (default value is disabled)
/// "_"   : Explicit normal field.
/// 
/// ## Restriction
/// ### Unfoldable type
/// * String
/// * Array
/// * Tuple
/// * Enum
/// * Struct
/// 
/// In other words, all type can be unfolded. Newtype resolves to one of the above types.
///
/// ### Mergeable type:    
/// * Struct
/// 
/// #### Not mergeable type:
/// * String
/// * Array
/// * Tuple
/// * Enum
/// '''
[newtype StructFieldName String]

/// [completion_self]
[newtype LibraryPath String]
/// [completion_self]
[newtype PackagePath String]
/// [completion_self]
[newtype ModulePath String]
/// [completion_self]
[newtype TypePath String]

/// [completion_const String]
/// [completion_const Array]
/// [completion_type TypeNameDeclaration]
[enum TypeReference
    [primitive< [type_path TypePath]]
    [generic< [type GenericTypeReference]]
]
[tuple GenericTypeReference
    [type_path TypePath] [parameters.. TypeReferenceParameter]
]
[newtype TypeReferenceParameter Any]
